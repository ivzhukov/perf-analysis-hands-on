"use strict";(self.webpackChunkperf_analysis=self.webpackChunkperf_analysis||[]).push([[8581],{5610:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Baseline measurement","href":"/perf-analysis-hands-on/docs/baseline","docId":"baseline","unlisted":false},{"type":"link","label":"Instrumentation","href":"/perf-analysis-hands-on/docs/instrumentation","docId":"instrumentation","unlisted":false},{"type":"link","label":"Filtering","href":"/perf-analysis-hands-on/docs/filtering","docId":"filtering","unlisted":false},{"type":"link","label":"Explore profile with CUBE","href":"/perf-analysis-hands-on/docs/profile_exploration","docId":"profile_exploration","unlisted":false},{"type":"link","label":"Scalasca trace analysis","href":"/perf-analysis-hands-on/docs/trace_analysis","docId":"trace_analysis","unlisted":false}]},"docs":{"baseline":{"id":"baseline","title":"Baseline measurement","description":"In this part we are going to build and run a specific benchmark to identify how long it runs without any specific tools (also called as a reference/baseline run). A reference run provides a valuable point of comparison and context for performance analysis, enabling more informed decision-making and effective optimization efforts.","sidebar":"tutorialSidebar"},"filtering":{"id":"filtering","title":"Filtering","description":"Congratulations, we have made our first measurement with Score-P. But how good was the measurement?","sidebar":"tutorialSidebar"},"instrumentation":{"id":"instrumentation","title":"Instrumentation","description":"As a next step we are going to instrument our application, i.e. insert additional code into our program to collect performance data during its execution. Instrumentation can be done either manually by the programmer or automatically by tools like Score-P. The data collected includes information about user function calls, communication events, synchronization events, and more.","sidebar":"tutorialSidebar"},"profile_exploration":{"id":"profile_exploration","title":"Explore profile with CUBE","description":"Congratulations, now we collected our first measurements with acceptable runtime dilation. This new measurement should accurately represent the real runtime behavior of the BT-MZ application, and can now be postprocessed and interactively explored using the Cube browser. These two steps can be conveniently initiated using the following command:","sidebar":"tutorialSidebar"},"trace_analysis":{"id":"trace_analysis","title":"Scalasca trace analysis","description":"While summary profiles only provide process- or thread-local data aggregated over time, event traces contain detailed time-stamped event data which also allows to reconstruct the dynamic behavior of an application. This enables tools such as the Scalasca trace analyzer to provide even more insights into the performance behavior of an application, for example, whether the time spent in MPI communication is real message processing time or incurs significant wait states (i.e., intervals where a process sits idle without doing useful work waiting for data from other processes to arrive).","sidebar":"tutorialSidebar"}}}')}}]);